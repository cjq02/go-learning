# AGENTS.md

This file provides guidance to Qoder (qoder.com) when working with code in this repository.

## Repository Overview

This is a Go language learning repository organized into numbered lesson modules (1.4 through 1.18), covering fundamental to advanced Go concepts. Each module contains focused examples demonstrating specific language features.

## Project Structure

The codebase follows a structured learning path:

- **Module naming**: `1.X_topic_name/` (e.g., `1.5_struct/`, `1.18_concurrency/`)
- **File naming**: `1.X.Y_subtopic.go` where X is the module number and Y is the lesson number
- **Package naming**: Each module is a separate package (e.g., `package structs`, `package concurrency`)
- **Main entry**: `main.go` contains a reflection-based demo runner that dynamically invokes example functions

### Key Architectural Patterns

1. **Demo Registry Pattern**: The `main.go` file uses a `demoRegistry` map to register all demo functions from various packages, enabling dynamic function lookup and invocation via reflection.

2. **Smart Alias System**: An `aliasRegistry` is auto-generated from `demoRegistry` keys by removing the "Demo" suffix and converting to camelCase, allowing flexible command-line input (e.g., `constants` â†’ `ConstantsDemo`).

3. **Module Organization**: Each topic module (`1.X_topic/`) contains:
   - Multiple numbered lesson files (`1.X.Y_subtopic.go`)
   - Exported demo functions named `<Topic>Demo()` (e.g., `StructMethodsDemo()`)
   - Comprehensive comments in Chinese explaining concepts
   - Self-contained examples with detailed output

4. **Method Receivers**: The codebase demonstrates both value receivers and pointer receivers for struct methods. Pointer receivers (`*Type`) are used when methods need to modify the receiver's state.

5. **Concurrency Patterns**: The `1.18_concurrency/` module demonstrates goroutines, channels, mutexes, and sync.WaitGroup for coordinating concurrent operations.

## Common Commands

### Running Examples

Run any demo by name using the smart lookup system:

```bash
# Run a specific demo (case-insensitive, with automatic suffix matching)
go run main.go constants
go run main.go anonymousStruct
go run main.go goroutine

# Show all available demos
go run main.go
```

### Building

```bash
# Build the project
go build -o go-learning main.go

# Run the binary
./go-learning <demo-name>
```

### Module Information

```bash
# View module dependencies
go list -m all

# Tidy dependencies
go mod tidy
```

## Code Conventions

1. **Comments**: Extensive Chinese comments explaining concepts, syntax, and behavior
2. **Naming**: PascalCase for exported identifiers, camelCase for unexported
3. **Package Structure**: One package per module directory
4. **Demo Functions**: Zero-parameter functions that demonstrate concepts with printed output
5. **No External Dependencies**: The project uses only Go standard library

## Adding New Examples

To add a new demo:

1. Create the demo function in the appropriate module file (or create a new module)
2. Export the function with a name ending in "Demo" (e.g., `NewFeatureDemo()`)
3. Register it in `main.go`'s `demoRegistry` map
4. The alias will be auto-generated by the `generateAliasRegistry()` function

Example:
```go
// In 1.X_module/1.X.Y_file.go
func NewFeatureDemo() {
    fmt.Println("=== New Feature Demo ===")
    // demonstration code
}

// In main.go demoRegistry
var demoRegistry = map[string]interface{}{
    // ... existing entries
    "NewFeatureDemo": modulename.NewFeatureDemo,
}
```
